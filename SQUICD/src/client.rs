use quiche::{Config, ConnectionId, RecvInfo};
use ring::rand::*;
use std::net::UdpSocket;
use std::time::Duration;
use std::error::Error;

// Import the common module
use crate::common::{Message, serialize_and_compress, decompress_and_deserialize};

/// Sends a message to the server at the specified address and waits for a response.
///
/// # Arguments
///
/// * `server_addr` - The server's address and port (e.g., "127.0.0.1:4433").
/// * `message` - The `Message` to send.
///
/// # Returns
///
/// A `Result` containing the response `Message` from the server or an error.
pub fn send_message(
    server_addr: &str,
    message: Message,
) -> Result<Message, Box<dyn Error>> {
    println!("Client starting...");

    // Maximum datagram size
    const MAX_DATAGRAM_SIZE: usize = 1350; // Standard MTU size

    // Create UDP socket bound to an ephemeral port
    let socket = UdpSocket::bind("0.0.0.0:0")?;

    // Server address
    let server_addr = server_addr.parse().unwrap();

    // Create QUIC configuration
    let mut config = Config::new(quiche::PROTOCOL_VERSION)?;
    config.set_application_protos(&[b"example-proto"])?;
    config.verify_peer(false);

    // Configure QUIC parameters
    config.set_max_idle_timeout(30_000);
    config.set_max_recv_udp_payload_size(MAX_DATAGRAM_SIZE);
    config.set_max_send_udp_payload_size(MAX_DATAGRAM_SIZE);
    config.set_initial_max_data(10_000_000);
    config.set_initial_max_stream_data_bidi_local(1_000_000);
    config.set_initial_max_streams_bidi(100);
    config.set_disable_active_migration(true);

    // Generate a random SCID
    let mut scid = [0; quiche::MAX_CONN_ID_LEN];
    SystemRandom::new()
        .fill(&mut scid)
        .expect("Failed to generate connection ID");
    let scid = ConnectionId::from_ref(&scid);

    // Create a new QUIC connection to the server
    let mut conn = quiche::connect(
        None,
        &scid,
        socket.local_addr().unwrap(),
        server_addr,
        &mut config,
    )?;

    // Buffers for sending and receiving data
    let mut out = [0; MAX_DATAGRAM_SIZE];
    let mut buf = [0; 65535];

    // Send the initial packet to start the handshake
    let (write, send_info) = conn.send(&mut out)?;
    socket.send_to(&out[..write], send_info.to)?;

    // Variables to track state
    let mut handshake_completed = false;
    let mut message_sent = false;
    let mut response_received = false;
    let mut received_message = None;

    // Initialize stream_id for client-initiated bidirectional streams
    let stream_id = 0u64; // First bidirectional stream

    loop {
        // Wait for data from the server
        socket.set_read_timeout(Some(Duration::from_millis(50)))?;
        match socket.recv_from(&mut buf) {
            Ok((len, from)) => {
                let recv_info = RecvInfo {
                    from,
                    to: socket.local_addr().unwrap(),
                };
                if let Err(e) = conn.recv(&mut buf[..len], recv_info) {
                    eprintln!("Connection recv failed: {:?}", e);
                    break;
                }
            }
            Err(ref e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                // Timeout, continue
            }
            Err(e) => {
                eprintln!("Failed to receive data: {:?}", e);
                break;
            }
        }

        // Once the handshake is established, send application data
        if conn.is_established() && !handshake_completed {
            println!("Handshake completed");
            handshake_completed = true;
        }

        if handshake_completed && !message_sent {
            // Serialize and compress the message
            let compressed_data = serialize_and_compress(&message)?;

            // Send the compressed data over QUIC
            match conn.stream_send(stream_id, &compressed_data, true) {
                Ok(_) => {
                    println!("Message sent on stream {}", stream_id);
                    message_sent = true;
                }
                Err(quiche::Error::Done) => {
                    // No more data can be sent at the moment
                }
                Err(e) => {
                    eprintln!("Failed to send data on stream {}: {:?}", stream_id, e);
                    break;
                }
            }
        }

        // Send any pending packets generated by `recv` or application data
        while let Ok((write, send_info)) = conn.send(&mut out) {
            socket.send_to(&out[..write], send_info.to)?;
        }

        // Read responses from the server
        for s_id in conn.readable() {
            while let Ok((read, fin)) = conn.stream_recv(s_id, &mut buf) {
                let data = &buf[..read];
                println!(
                    "Client received {} bytes on stream {} (fin: {})",
                    data.len(),
                    s_id,
                    fin
                );
                if fin {
                    // Decompress and deserialize the response
                    let response = decompress_and_deserialize(data)?;
                    println!("Received response: {:?}", response);
                    received_message = Some(response);
                    response_received = true;
                    // Close the connection gracefully
                    conn.close(false, 0x00, b"done")?;
                    break;
                }
            }
        }

        // Handle connection close
        if conn.is_closed() {
            println!("Connection closed");
            break;
        }

        if response_received {
            println!("Response received, exiting loop");
            break;
        }
    }

    if let Some(msg) = received_message {
        Ok(msg)
    } else {
        Err("No response received".into())
    }
}
